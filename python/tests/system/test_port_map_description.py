"""
SPDX-FileCopyrightText: Copyright (c) 2025 NVIDIA CORPORATION & AFFILIATES. All rights reserved.
SPDX-License-Identifier: Apache-2.0

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
"""  # noqa: E501

import yaml

from holoscan.core import Application, Fragment, Operator, OperatorSpec
from holoscan.operators import PingRxOp, PingTxOp


class DummyForkOp(Operator):
    """Operator used for testing port_map_description.

    Don't need to implement compute as we will not call run() in the test application.
    """

    def setup(self, spec: OperatorSpec):
        spec.input("in")
        spec.output("out-1")
        spec.output("out-2")  # use default port map delimiter in the operator name


class DummyJoinOp(Operator):
    """Operator used for testing port_map_description.

    Don't need to implement compute as we will not call run() in the test application.
    """

    def setup(self, spec: OperatorSpec):
        spec.input("in-1")
        spec.input("in-2")
        spec.output("out")


class MyBasicPortMap(Application):
    """Application used for testing port_map_description

    This application is used to test the port_map_description method for a basic application.
    The test case should call compose(), but does not need to call run().
    """

    def compose(self):
        tx = PingTxOp(self, name="tx")
        fork = DummyForkOp(self, name="fork")
        join = DummyJoinOp(self, name="join")
        rx = PingRxOp(self, name="rx")
        self.add_flow(tx, fork)
        self.add_flow(tx, rx)
        self.add_flow(fork, join, {("out-1", "in-1"), ("out-2", "in-2")})
        self.add_flow(join, rx, {("out", "in")})


def test_port_map_description():
    app = MyBasicPortMap()
    # manually compose the dummy application so we don't have to run() to test the port map
    app.compose()

    port_map = app.graph.port_map_description()
    assert isinstance(port_map, str)

    # validate YAML generated by port map description is as expected
    actual_yaml = yaml.safe_load(port_map)
    expected_yaml = yaml.safe_load("""input_to_output:
  fork.in:
    - tx.out
  join.in-1:
    - fork.out-1
  join.in-2:
    - fork.out-2
  rx.in:
    - join.out
    - tx.out
output_to_input:
  fork.out-1:
    - join.in-1
  fork.out-2:
    - join.in-2
  join.out:
    - rx.in
  tx.out:
    - fork.in
    - rx.in
""")
    assert actual_yaml == expected_yaml


def test_get_port_connectivity_maps():
    app = MyBasicPortMap()
    # manually compose the dummy application so we don't have to run() to test the port map
    app.compose()

    connection_maps = app.graph.get_port_connectivity_maps()
    assert isinstance(connection_maps, tuple)
    assert len(connection_maps) == 2, "expected a pair of connection maps"

    out_to_in_map = {
        "fork.in": ["tx.out"],
        "join.in-1": ["fork.out-1"],
        "join.in-2": ["fork.out-2"],
        "rx.in": ["join.out", "tx.out"],
    }
    assert connection_maps[0] == out_to_in_map

    in_to_out_map = {
        "fork.out-1": ["join.in-1"],
        "fork.out-2": ["join.in-2"],
        "join.out": ["rx.in"],
        "tx.out": ["fork.in", "rx.in"],
    }
    assert connection_maps[1] == in_to_out_map


class TxFragment(Fragment):
    def compose(self):
        tx = PingTxOp(self, name="tx")
        fork = DummyForkOp(self, name="fork")
        self.add_flow(tx, fork)


class RxFragment(Fragment):
    def compose(self):
        join = DummyJoinOp(self, name="join")
        rx = PingRxOp(self, name="rx")
        self.add_flow(join, rx, {("out", "in")})


class MyDistributedPortMap(Application):
    """Dummy distributed application used for testing port_map_description

    This application is used to test the port_map_description method for a basic application.

    The test case should call compose() on the application as a whole and on each fragment
    that is returned by `fragment_graph.get_nodes()`. The test case should not call run() on
    this application because compute methods are not actually implemented for the dummy
    operators used.
    """

    def compose(self):
        tx_fragment = TxFragment(self, name="source")
        rx_fragment = RxFragment(self, name="sink")
        self.add_flow(tx_fragment, rx_fragment, {("tx.out", "rx.in")})
        self.add_flow(
            tx_fragment, rx_fragment, {("fork.out-1", "join.in-1"), ("fork.out-2", "join.in-2")}
        )


def test_distributed_port_map_description():
    app = MyDistributedPortMap()

    fragment_descriptions = []

    # manually compose the dummy application so we don't have to run() to test the port map
    app.compose()
    for fragment in app.fragment_graph.get_nodes():
        fragment.compose()
        fragment_descriptions.append(fragment.graph.port_map_description())

    assert len(fragment_descriptions) == 2, "Expected one description for each fragment"
    assert all(isinstance(d, str) for d in fragment_descriptions)

    # validate YAML of inter-fragment connections

    inter_fragment_port_map = app.fragment_graph.port_map_description()
    assert isinstance(inter_fragment_port_map, str)

    # validate YAML generated by port map description is as expected
    actual_yaml = yaml.safe_load(inter_fragment_port_map)
    expected_yaml = yaml.safe_load("""input_to_output:
  sink.join.in-1:
    - source.fork.out-1
  sink.join.in-2:
    - source.fork.out-2
  sink.rx.in:
    - source.tx.out
output_to_input:
  source.fork.out-1:
    - sink.join.in-1
  source.fork.out-2:
    - sink.join.in-2
  source.tx.out:
    - sink.rx.in""")
    assert actual_yaml == expected_yaml

    # validate YAML of intra-fragment connections for fragment 1 (source)
    fragment1_yaml = yaml.safe_load(fragment_descriptions[0])
    expected_fragment1_yaml = yaml.safe_load("""input_to_output:
  source.fork.in:
    - source.tx.out
output_to_input:
  source.tx.out:
    - source.fork.in
""")
    assert fragment1_yaml == expected_fragment1_yaml, "mismatch in YAML for fragment 1"

    # validate YAML of intra-fragment connections for fragment 2 (sink)
    fragment2_yaml = yaml.safe_load(fragment_descriptions[1])
    expected_fragment2_yaml = yaml.safe_load("""input_to_output:
  sink.rx.in:
    - sink.join.out
output_to_input:
  sink.join.out:
    - sink.rx.in""")
    assert fragment2_yaml == expected_fragment2_yaml, "mismatch in YAML for fragment 2"


def test_distributed_get_port_connectivity_maps():
    app = MyDistributedPortMap()
    # manually compose the dummy application so we don't have to run() to test the port map
    app.compose()

    inter_fragment_connection_maps = app.fragment_graph.get_port_connectivity_maps()
    assert isinstance(inter_fragment_connection_maps, tuple)
    assert len(inter_fragment_connection_maps) == 2, "expected a pair of connection maps"

    expected_first = {
        "sink.join.in-1": ["source.fork.out-1"],
        "sink.join.in-2": ["source.fork.out-2"],
        "sink.rx.in": ["source.tx.out"],
    }
    assert inter_fragment_connection_maps[0] == expected_first
    expected_second = {
        "source.fork.out-1": ["sink.join.in-1"],
        "source.fork.out-2": ["sink.join.in-2"],
        "source.tx.out": ["sink.rx.in"],
    }
    assert inter_fragment_connection_maps[1] == expected_second

    all_fragment_connection_maps = []
    for fragment in app.fragment_graph.get_nodes():
        fragment.compose()
        connection_maps = fragment.graph.get_port_connectivity_maps()
        all_fragment_connection_maps.append(connection_maps)
        assert isinstance(connection_maps, tuple)
        assert len(connection_maps) == 2, "expected a pair of connection maps"
        print(f"{connection_maps=}")

    source_connections, sink_connections = all_fragment_connection_maps

    expected_sink_first = {"sink.rx.in": ["sink.join.out"]}
    expected_sink_second = {"sink.join.out": ["sink.rx.in"]}
    assert sink_connections[0] == expected_sink_first
    assert sink_connections[1] == expected_sink_second

    expected_source_first = {"source.fork.in": ["source.tx.out"]}
    expected_source_second = {"source.tx.out": ["source.fork.in"]}
    assert source_connections[0] == expected_source_first
    assert source_connections[1] == expected_source_second
